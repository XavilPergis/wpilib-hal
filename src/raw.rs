/* automatically generated by rust-bindgen */

#[allow(non_snake_case_name)]

pub const HAL_kInvalidHandle: ::std::os::raw::c_uint = 0;
pub const HAL_IO_CONFIG_DATA_SIZE: ::std::os::raw::c_uint = 32;
pub const HAL_SYS_STATUS_DATA_SIZE: ::std::os::raw::c_uint = 44;
pub const HAL_USER_STATUS_DATA_SIZE: ::std::os::raw::c_uint = 908;
pub const HALFRC_NetworkCommunication_DynamicType_DSEnhancedIO_Input: ::std::os::raw::c_uint = 17;
pub const HALFRC_NetworkCommunication_DynamicType_DSEnhancedIO_Output: ::std::os::raw::c_uint = 18;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Header: ::std::os::raw::c_uint = 19;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Extra1: ::std::os::raw::c_uint = 20;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Vertices1: ::std::os::raw::c_uint = 21;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Extra2: ::std::os::raw::c_uint = 22;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Vertices2: ::std::os::raw::c_uint = 23;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Joystick: ::std::os::raw::c_uint = 24;
pub const HALFRC_NetworkCommunication_DynamicType_Kinect_Custom: ::std::os::raw::c_uint = 25;
pub const HAL_kMaxJoystickAxes: ::std::os::raw::c_uint = 12;
pub const HAL_kMaxJoystickPOVs: ::std::os::raw::c_uint = 12;
pub const CTR_RxTimeout_MESSAGE: &'static [u8; 25usize] = b"CTRE CAN Receive Timeout\x00";
pub const CTR_TxTimeout_MESSAGE: &'static [u8; 26usize] = b"CTRE CAN Transmit Timeout\x00";
pub const CTR_InvalidParamValue_MESSAGE: &'static [u8; 27usize] = b"CTRE CAN Invalid Parameter\x00";
pub const CTR_UnexpectedArbId_MESSAGE: &'static [u8; 45usize] = b"CTRE Unexpected Arbitration ID (CAN Node ID)\x00";
pub const CTR_TxFailed_MESSAGE: &'static [u8; 24usize] = b"CTRE CAN Transmit Error\x00";
pub const CTR_SigNotUpdated_MESSAGE: &'static [u8; 28usize] = b"CTRE CAN Signal Not Updated\x00";
pub const NiFpga_Status_FifoTimeout_MESSAGE: &'static [u8; 27usize] = b"NIFPGA: FIFO timeout error\x00";
pub const NiFpga_Status_TransferAborted_MESSAGE: &'static [u8; 31usize] = b"NIFPGA: Transfer aborted error\x00";
pub const NiFpga_Status_MemoryFull_MESSAGE: &'static [u8; 46usize] = b"NIFPGA: Memory Allocation failed, memory full\x00";
pub const NiFpga_Status_SoftwareFault_MESSAGE: &'static [u8; 34usize] = b"NIFPGA: Unexpected software error\x00";
pub const NiFpga_Status_InvalidParameter_MESSAGE: &'static [u8; 26usize] = b"NIFPGA: Invalid Parameter\x00";
pub const NiFpga_Status_ResourceNotFound_MESSAGE: &'static [u8; 27usize] = b"NIFPGA: Resource not found\x00";
pub const NiFpga_Status_ResourceNotInitialized_MESSAGE: &'static [u8; 33usize] = b"NIFPGA: Resource not initialized\x00";
pub const NiFpga_Status_HardwareFault_MESSAGE: &'static [u8; 23usize] = b"NIFPGA: Hardware Fault\x00";
pub const NiFpga_Status_IrqTimeout_MESSAGE: &'static [u8; 26usize] = b"NIFPGA: Interrupt timeout\x00";
pub const ERR_CANSessionMux_InvalidBuffer_MESSAGE: &'static [u8; 20usize] = b"CAN: Invalid Buffer\x00";
pub const ERR_CANSessionMux_MessageNotFound_MESSAGE: &'static [u8; 23usize] = b"CAN: Message not found\x00";
pub const WARN_CANSessionMux_NoToken_MESSAGE: &'static [u8; 14usize] = b"CAN: No token\x00";
pub const ERR_CANSessionMux_NotAllowed_MESSAGE: &'static [u8; 17usize] = b"CAN: Not allowed\x00";
pub const ERR_CANSessionMux_NotInitialized_MESSAGE: &'static [u8; 21usize] = b"CAN: Not initialized\x00";
pub const SAMPLE_RATE_TOO_HIGH: ::std::os::raw::c_uint = 1001;
pub const SAMPLE_RATE_TOO_HIGH_MESSAGE: &'static [u8; 43usize] = b"HAL: Analog module sample rate is too high\x00";
pub const VOLTAGE_OUT_OF_RANGE: ::std::os::raw::c_uint = 1002;
pub const VOLTAGE_OUT_OF_RANGE_MESSAGE: &'static [u8; 60usize] = b"HAL: Voltage to convert to raw value is out of range [0; 5]\x00";
pub const LOOP_TIMING_ERROR: ::std::os::raw::c_uint = 1004;
pub const LOOP_TIMING_ERROR_MESSAGE: &'static [u8; 58usize] = b"HAL: Digital module loop timing is not the expected value\x00";
pub const SPI_WRITE_NO_MOSI: ::std::os::raw::c_uint = 1012;
pub const SPI_WRITE_NO_MOSI_MESSAGE: &'static [u8; 50usize] = b"HAL: Cannot write to SPI port with no MOSI output\x00";
pub const SPI_READ_NO_MISO: ::std::os::raw::c_uint = 1013;
pub const SPI_READ_NO_MISO_MESSAGE: &'static [u8; 50usize] = b"HAL: Cannot read from SPI port with no MISO input\x00";
pub const SPI_READ_NO_DATA: ::std::os::raw::c_uint = 1014;
pub const SPI_READ_NO_DATA_MESSAGE: &'static [u8; 40usize] = b"HAL: No data available to read from SPI\x00";
pub const INCOMPATIBLE_STATE: ::std::os::raw::c_uint = 1015;
pub const INCOMPATIBLE_STATE_MESSAGE: &'static [u8; 59usize] = b"HAL: Incompatible State: The operation cannot be completed\x00";
pub const NO_AVAILABLE_RESOURCES: ::std::os::raw::c_int = -1004;
pub const NO_AVAILABLE_RESOURCES_MESSAGE: &'static [u8; 40usize] = b"HAL: No available resources to allocate\x00";
pub const NULL_PARAMETER: ::std::os::raw::c_int = -1005;
pub const NULL_PARAMETER_MESSAGE: &'static [u8; 45usize] = b"HAL: A pointer parameter to a method is NULL\x00";
pub const ANALOG_TRIGGER_LIMIT_ORDER_ERROR: ::std::os::raw::c_int = -1010;
pub const ANALOG_TRIGGER_LIMIT_ORDER_ERROR_MESSAGE: &'static [u8; 60usize] = b"HAL: AnalogTrigger limits error.  Lower limit > Upper Limit\x00";
pub const ANALOG_TRIGGER_PULSE_OUTPUT_ERROR: ::std::os::raw::c_int = -1011;
pub const ANALOG_TRIGGER_PULSE_OUTPUT_ERROR_MESSAGE: &'static [u8; 51usize] = b"HAL: Attempted to read AnalogTrigger pulse output.\x00";
pub const PARAMETER_OUT_OF_RANGE: ::std::os::raw::c_int = -1028;
pub const PARAMETER_OUT_OF_RANGE_MESSAGE: &'static [u8; 34usize] = b"HAL: A parameter is out of range.\x00";
pub const RESOURCE_IS_ALLOCATED: ::std::os::raw::c_int = -1029;
pub const RESOURCE_IS_ALLOCATED_MESSAGE: &'static [u8; 32usize] = b"HAL: Resource already allocated\x00";
pub const RESOURCE_OUT_OF_RANGE: ::std::os::raw::c_int = -1030;
pub const RESOURCE_OUT_OF_RANGE_MESSAGE: &'static [u8; 45usize] = b"HAL: The requested resource is out of range.\x00";
pub const HAL_INVALID_ACCUMULATOR_CHANNEL: ::std::os::raw::c_int = -1035;
pub const HAL_INVALID_ACCUMULATOR_CHANNEL_MESSAGE: &'static [u8; 55usize] = b"HAL: The requested input is not an accumulator channel\x00";
pub const HAL_COUNTER_NOT_SUPPORTED: ::std::os::raw::c_int = -1058;
pub const HAL_COUNTER_NOT_SUPPORTED_MESSAGE: &'static [u8; 51usize] = b"HAL: Counter mode not supported for encoder method\x00";
pub const HAL_PWM_SCALE_ERROR: ::std::os::raw::c_int = -1072;
pub const HAL_PWM_SCALE_ERROR_MESSAGE: &'static [u8; 44usize] = b"HAL: The PWM Scale Factors are out of range\x00";
pub const HAL_HANDLE_ERROR: ::std::os::raw::c_int = -1098;
pub const HAL_HANDLE_ERROR_MESSAGE: &'static [u8; 47usize] = b"HAL: A handle parameter was passed incorrectly\x00";
pub const HAL_SERIAL_PORT_NOT_FOUND: ::std::os::raw::c_int = -1123;
pub const HAL_SERIAL_PORT_NOT_FOUND_MESSAGE: &'static [u8; 52usize] = b"HAL: The specified serial port device was not found\x00";
pub const HAL_SERIAL_PORT_OPEN_ERROR: ::std::os::raw::c_int = -1124;
pub const HAL_SERIAL_PORT_OPEN_ERROR_MESSAGE: &'static [u8; 41usize] = b"HAL: The serial port could not be opened\x00";
pub const HAL_SERIAL_PORT_ERROR: ::std::os::raw::c_int = -1125;
pub const HAL_SERIAL_PORT_ERROR_MESSAGE: &'static [u8; 43usize] = b"HAL: There was an error on the serial port\x00";
pub const HAL_THREAD_PRIORITY_ERROR: ::std::os::raw::c_int = -1152;
pub const HAL_THREAD_PRIORITY_RANGE_ERROR: ::std::os::raw::c_int = -1153;
pub const HAL_THREAD_PRIORITY_RANGE_ERROR_MESSAGE: &'static [u8; 49usize] = b"HAL: The priority requested to be set is invalid\x00";
pub const VI_ERROR_INV_OBJECT_MESSAGE: &'static [u8; 27usize] = b"HAL - VISA: Invalid Object\x00";
pub const VI_ERROR_RSRC_LOCKED_MESSAGE: &'static [u8; 28usize] = b"HAL - VISA: Resource Locked\x00";
pub const VI_ERROR_RSRC_NFOUND_MESSAGE: &'static [u8; 31usize] = b"HAL - VISA: Resource Not Found\x00";
pub const VI_ERROR_INV_RSRC_NAME_MESSAGE: &'static [u8; 34usize] = b"HAL - VISA: Invalid Resource Name\x00";
pub const VI_ERROR_QUEUE_OVERFLOW_MESSAGE: &'static [u8; 27usize] = b"HAL - VISA: Queue Overflow\x00";
pub const VI_ERROR_IO_MESSAGE: &'static [u8; 29usize] = b"HAL - VISA: General IO Error\x00";
pub const VI_ERROR_ASRL_PARITY_MESSAGE: &'static [u8; 25usize] = b"HAL - VISA: Parity Error\x00";
pub const VI_ERROR_ASRL_FRAMING_MESSAGE: &'static [u8; 26usize] = b"HAL - VISA: Framing Error\x00";
pub const VI_ERROR_ASRL_OVERRUN_MESSAGE: &'static [u8; 33usize] = b"HAL - VISA: Buffer Overrun Error\x00";
pub const VI_ERROR_RSRC_BUSY_MESSAGE: &'static [u8; 26usize] = b"HAL - VISA: Resource Busy\x00";
pub const VI_ERROR_INV_PARAMETER_MESSAGE: &'static [u8; 30usize] = b"HAL - VISA: Invalid Parameter\x00";
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const CAN_SEND_PERIOD_NO_REPEAT: ::std::os::raw::c_uint = 0;
pub const CAN_SEND_PERIOD_STOP_REPEATING: ::std::os::raw::c_int = -1;
pub const CAN_IS_FRAME_REMOTE: ::std::os::raw::c_uint = 2147483648;
pub const CAN_IS_FRAME_11BIT: ::std::os::raw::c_uint = 1073741824;
pub const ERR_CANSessionMux_InvalidBuffer: ::std::os::raw::c_int = -44086;
pub const ERR_CANSessionMux_MessageNotFound: ::std::os::raw::c_int = -44087;
pub const WARN_CANSessionMux_NoToken: ::std::os::raw::c_uint = 44087;
pub const ERR_CANSessionMux_NotAllowed: ::std::os::raw::c_int = -44088;
pub const ERR_CANSessionMux_NotInitialized: ::std::os::raw::c_int = -44089;
pub const ERR_CANSessionMux_SessionOverrun: ::std::os::raw::c_uint = 44050;
pub type HAL_Handle = i32;
pub type HAL_PortHandle = HAL_Handle;
pub type HAL_AnalogInputHandle = HAL_Handle;
pub type HAL_AnalogOutputHandle = HAL_Handle;
pub type HAL_AnalogTriggerHandle = HAL_Handle;
pub type HAL_CompressorHandle = HAL_Handle;
pub type HAL_CounterHandle = HAL_Handle;
pub type HAL_DigitalHandle = HAL_Handle;
pub type HAL_DigitalPWMHandle = HAL_Handle;
pub type HAL_EncoderHandle = HAL_Handle;
pub type HAL_FPGAEncoderHandle = HAL_Handle;
pub type HAL_GyroHandle = HAL_Handle;
pub type HAL_InterruptHandle = HAL_Handle;
pub type HAL_NotifierHandle = HAL_Handle;
pub type HAL_RelayHandle = HAL_Handle;
pub type HAL_SolenoidHandle = HAL_Handle;
pub type HAL_Bool = i32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAL_AccelerometerRange {
    HAL_AccelerometerRange_k2G = 0,
    HAL_AccelerometerRange_k4G = 1,
    HAL_AccelerometerRange_k8G = 2,
}
extern "C" {
    pub fn HAL_SetAccelerometerActive(active: HAL_Bool);
}
extern "C" {
    pub fn HAL_SetAccelerometerRange(range: HAL_AccelerometerRange);
}
extern "C" {
    pub fn HAL_GetAccelerometerX() -> f64;
}
extern "C" {
    pub fn HAL_GetAccelerometerY() -> f64;
}
extern "C" {
    pub fn HAL_GetAccelerometerZ() -> f64;
}
extern "C" {
    pub fn HAL_IsAccumulatorChannel(analogPortHandle: HAL_AnalogInputHandle,
                                    status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_InitAccumulator(analogPortHandle: HAL_AnalogInputHandle,
                               status: *mut i32);
}
extern "C" {
    pub fn HAL_ResetAccumulator(analogPortHandle: HAL_AnalogInputHandle,
                                status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAccumulatorCenter(analogPortHandle: HAL_AnalogInputHandle,
                                    center: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAccumulatorDeadband(analogPortHandle: HAL_AnalogInputHandle,
                                      deadband: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetAccumulatorValue(analogPortHandle: HAL_AnalogInputHandle,
                                   status: *mut i32) -> i64;
}
extern "C" {
    pub fn HAL_GetAccumulatorCount(analogPortHandle: HAL_AnalogInputHandle,
                                   status: *mut i32) -> i64;
}
extern "C" {
    pub fn HAL_GetAccumulatorOutput(analogPortHandle: HAL_AnalogInputHandle,
                                    value: *mut i64, count: *mut i64,
                                    status: *mut i32);
}
extern "C" {
    pub fn HAL_InitializeAnalogGyro(handle: HAL_AnalogInputHandle,
                                    status: *mut i32) -> HAL_GyroHandle;
}
extern "C" {
    pub fn HAL_SetupAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_FreeAnalogGyro(handle: HAL_GyroHandle);
}
extern "C" {
    pub fn HAL_SetAnalogGyroParameters(handle: HAL_GyroHandle,
                                       voltsPerDegreePerSecond: f64,
                                       offset: f64, center: i32,
                                       status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAnalogGyroVoltsPerDegreePerSecond(handle: HAL_GyroHandle,
                                                    voltsPerDegreePerSecond:
                                                        f64,
                                                    status: *mut i32);
}
extern "C" {
    pub fn HAL_ResetAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_CalibrateAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAnalogGyroDeadband(handle: HAL_GyroHandle, volts: f64,
                                     status: *mut i32);
}
extern "C" {
    pub fn HAL_GetAnalogGyroAngle(handle: HAL_GyroHandle, status: *mut i32)
     -> f64;
}
extern "C" {
    pub fn HAL_GetAnalogGyroRate(handle: HAL_GyroHandle, status: *mut i32)
     -> f64;
}
extern "C" {
    pub fn HAL_GetAnalogGyroOffset(handle: HAL_GyroHandle, status: *mut i32)
     -> f64;
}
extern "C" {
    pub fn HAL_GetAnalogGyroCenter(handle: HAL_GyroHandle, status: *mut i32)
     -> i32;
}
extern "C" {
    pub fn HAL_InitializeAnalogInputPort(portHandle: HAL_PortHandle,
                                         status: *mut i32)
     -> HAL_AnalogInputHandle;
}
extern "C" {
    pub fn HAL_FreeAnalogInputPort(analogPortHandle: HAL_AnalogInputHandle);
}
extern "C" {
    pub fn HAL_CheckAnalogModule(module: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_CheckAnalogInputChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetAnalogSampleRate(samplesPerSecond: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetAnalogSampleRate(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_SetAnalogAverageBits(analogPortHandle: HAL_AnalogInputHandle,
                                    bits: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetAnalogAverageBits(analogPortHandle: HAL_AnalogInputHandle,
                                    status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_SetAnalogOversampleBits(analogPortHandle:
                                           HAL_AnalogInputHandle, bits: i32,
                                       status: *mut i32);
}
extern "C" {
    pub fn HAL_GetAnalogOversampleBits(analogPortHandle:
                                           HAL_AnalogInputHandle,
                                       status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetAnalogValue(analogPortHandle: HAL_AnalogInputHandle,
                              status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetAnalogAverageValue(analogPortHandle: HAL_AnalogInputHandle,
                                     status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetAnalogVoltsToValue(analogPortHandle: HAL_AnalogInputHandle,
                                     voltage: f64, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetAnalogVoltage(analogPortHandle: HAL_AnalogInputHandle,
                                status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetAnalogAverageVoltage(analogPortHandle:
                                           HAL_AnalogInputHandle,
                                       status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetAnalogLSBWeight(analogPortHandle: HAL_AnalogInputHandle,
                                  status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetAnalogOffset(analogPortHandle: HAL_AnalogInputHandle,
                               status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_InitializeAnalogOutputPort(portHandle: HAL_PortHandle,
                                          status: *mut i32)
     -> HAL_AnalogOutputHandle;
}
extern "C" {
    pub fn HAL_FreeAnalogOutputPort(analogOutputHandle:
                                        HAL_AnalogOutputHandle);
}
extern "C" {
    pub fn HAL_SetAnalogOutput(analogOutputHandle: HAL_AnalogOutputHandle,
                               voltage: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetAnalogOutput(analogOutputHandle: HAL_AnalogOutputHandle,
                               status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_CheckAnalogOutputChannel(channel: i32) -> HAL_Bool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAL_AnalogTriggerType {
    HAL_Trigger_kInWindow = 0,
    HAL_Trigger_kState = 1,
    HAL_Trigger_kRisingPulse = 2,
    HAL_Trigger_kFallingPulse = 3,
}
extern "C" {
    pub fn HAL_InitializeAnalogTrigger(portHandle: HAL_AnalogInputHandle,
                                       index: *mut i32, status: *mut i32)
     -> HAL_AnalogTriggerHandle;
}
extern "C" {
    pub fn HAL_CleanAnalogTrigger(analogTriggerHandle:
                                      HAL_AnalogTriggerHandle,
                                  status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAnalogTriggerLimitsRaw(analogTriggerHandle:
                                             HAL_AnalogTriggerHandle,
                                         lower: i32, upper: i32,
                                         status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAnalogTriggerLimitsVoltage(analogTriggerHandle:
                                                 HAL_AnalogTriggerHandle,
                                             lower: f64, upper: f64,
                                             status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAnalogTriggerAveraged(analogTriggerHandle:
                                            HAL_AnalogTriggerHandle,
                                        useAveragedValue: HAL_Bool,
                                        status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAnalogTriggerFiltered(analogTriggerHandle:
                                            HAL_AnalogTriggerHandle,
                                        useFilteredValue: HAL_Bool,
                                        status: *mut i32);
}
extern "C" {
    pub fn HAL_GetAnalogTriggerInWindow(analogTriggerHandle:
                                            HAL_AnalogTriggerHandle,
                                        status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetAnalogTriggerTriggerState(analogTriggerHandle:
                                                HAL_AnalogTriggerHandle,
                                            status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetAnalogTriggerOutput(analogTriggerHandle:
                                          HAL_AnalogTriggerHandle,
                                      type_: HAL_AnalogTriggerType,
                                      status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_InitializeCompressor(module: i32, status: *mut i32)
     -> HAL_CompressorHandle;
}
extern "C" {
    pub fn HAL_CheckCompressorModule(module: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCompressor(compressorHandle: HAL_CompressorHandle,
                             status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetCompressorClosedLoopControl(compressorHandle:
                                                  HAL_CompressorHandle,
                                              value: HAL_Bool,
                                              status: *mut i32);
}
extern "C" {
    pub fn HAL_GetCompressorClosedLoopControl(compressorHandle:
                                                  HAL_CompressorHandle,
                                              status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCompressorPressureSwitch(compressorHandle:
                                               HAL_CompressorHandle,
                                           status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCompressorCurrent(compressorHandle: HAL_CompressorHandle,
                                    status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetCompressorCurrentTooHighFault(compressorHandle:
                                                    HAL_CompressorHandle,
                                                status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCompressorCurrentTooHighStickyFault(compressorHandle:
                                                          HAL_CompressorHandle,
                                                      status: *mut i32)
     -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCompressorShortedStickyFault(compressorHandle:
                                                   HAL_CompressorHandle,
                                               status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCompressorShortedFault(compressorHandle:
                                             HAL_CompressorHandle,
                                         status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCompressorNotConnectedStickyFault(compressorHandle:
                                                        HAL_CompressorHandle,
                                                    status: *mut i32)
     -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCompressorNotConnectedFault(compressorHandle:
                                                  HAL_CompressorHandle,
                                              status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetSystemClockTicksPerMicrosecond() -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAL_Counter_Mode {
    HAL_Counter_kTwoPulse = 0,
    HAL_Counter_kSemiperiod = 1,
    HAL_Counter_kPulseLength = 2,
    HAL_Counter_kExternalDirection = 3,
}
extern "C" {
    pub fn HAL_InitializeCounter(mode: HAL_Counter_Mode, index: *mut i32,
                                 status: *mut i32) -> HAL_CounterHandle;
}
extern "C" {
    pub fn HAL_FreeCounter(counterHandle: HAL_CounterHandle,
                           status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterAverageSize(counterHandle: HAL_CounterHandle,
                                     size: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterUpSource(counterHandle: HAL_CounterHandle,
                                  digitalSourceHandle: HAL_Handle,
                                  analogTriggerType: HAL_AnalogTriggerType,
                                  status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterUpSourceEdge(counterHandle: HAL_CounterHandle,
                                      risingEdge: HAL_Bool,
                                      fallingEdge: HAL_Bool,
                                      status: *mut i32);
}
extern "C" {
    pub fn HAL_ClearCounterUpSource(counterHandle: HAL_CounterHandle,
                                    status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterDownSource(counterHandle: HAL_CounterHandle,
                                    digitalSourceHandle: HAL_Handle,
                                    analogTriggerType: HAL_AnalogTriggerType,
                                    status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterDownSourceEdge(counterHandle: HAL_CounterHandle,
                                        risingEdge: HAL_Bool,
                                        fallingEdge: HAL_Bool,
                                        status: *mut i32);
}
extern "C" {
    pub fn HAL_ClearCounterDownSource(counterHandle: HAL_CounterHandle,
                                      status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterUpDownMode(counterHandle: HAL_CounterHandle,
                                    status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterExternalDirectionMode(counterHandle:
                                                   HAL_CounterHandle,
                                               status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterSemiPeriodMode(counterHandle: HAL_CounterHandle,
                                        highSemiPeriod: HAL_Bool,
                                        status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterPulseLengthMode(counterHandle: HAL_CounterHandle,
                                         threshold: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetCounterSamplesToAverage(counterHandle: HAL_CounterHandle,
                                          status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_SetCounterSamplesToAverage(counterHandle: HAL_CounterHandle,
                                          samplesToAverage: i32,
                                          status: *mut i32);
}
extern "C" {
    pub fn HAL_ResetCounter(counterHandle: HAL_CounterHandle,
                            status: *mut i32);
}
extern "C" {
    pub fn HAL_GetCounter(counterHandle: HAL_CounterHandle, status: *mut i32)
     -> i32;
}
extern "C" {
    pub fn HAL_GetCounterPeriod(counterHandle: HAL_CounterHandle,
                                status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_SetCounterMaxPeriod(counterHandle: HAL_CounterHandle,
                                   maxPeriod: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterUpdateWhenEmpty(counterHandle: HAL_CounterHandle,
                                         enabled: HAL_Bool, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetCounterStopped(counterHandle: HAL_CounterHandle,
                                 status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCounterDirection(counterHandle: HAL_CounterHandle,
                                   status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetCounterReverseDirection(counterHandle: HAL_CounterHandle,
                                          reverseDirection: HAL_Bool,
                                          status: *mut i32);
}
extern "C" {
    pub fn HAL_InitializeDIOPort(portHandle: HAL_PortHandle, input: HAL_Bool,
                                 status: *mut i32) -> HAL_DigitalHandle;
}
extern "C" {
    pub fn HAL_CheckDIOChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_FreeDIOPort(dioPortHandle: HAL_DigitalHandle);
}
extern "C" {
    pub fn HAL_AllocateDigitalPWM(status: *mut i32) -> HAL_DigitalPWMHandle;
}
extern "C" {
    pub fn HAL_FreeDigitalPWM(pwmGenerator: HAL_DigitalPWMHandle,
                              status: *mut i32);
}
extern "C" {
    pub fn HAL_SetDigitalPWMRate(rate: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetDigitalPWMDutyCycle(pwmGenerator: HAL_DigitalPWMHandle,
                                      dutyCycle: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetDigitalPWMOutputChannel(pwmGenerator: HAL_DigitalPWMHandle,
                                          channel: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetDIO(dioPortHandle: HAL_DigitalHandle, value: HAL_Bool,
                      status: *mut i32);
}
extern "C" {
    pub fn HAL_GetDIO(dioPortHandle: HAL_DigitalHandle, status: *mut i32)
     -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetDIODirection(dioPortHandle: HAL_DigitalHandle,
                               status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_Pulse(dioPortHandle: HAL_DigitalHandle, pulseLength: f64,
                     status: *mut i32);
}
extern "C" {
    pub fn HAL_IsPulsing(dioPortHandle: HAL_DigitalHandle, status: *mut i32)
     -> HAL_Bool;
}
extern "C" {
    pub fn HAL_IsAnyPulsing(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetFilterSelect(dioPortHandle: HAL_DigitalHandle,
                               filterIndex: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetFilterSelect(dioPortHandle: HAL_DigitalHandle,
                               status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_SetFilterPeriod(filterIndex: i32, value: i64,
                               status: *mut i32);
}
extern "C" {
    pub fn HAL_GetFilterPeriod(filterIndex: i32, status: *mut i32) -> i64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HAL_ControlWord {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_HAL_ControlWord() {
    assert_eq!(::std::mem::size_of::<HAL_ControlWord>() , 4usize);
    assert_eq!(::std::mem::align_of::<HAL_ControlWord>() , 4usize);
}
impl Clone for HAL_ControlWord {
    fn clone(&self) -> Self { *self }
}
impl HAL_ControlWord {
    #[inline]
    pub fn enabled(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn autonomous(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_autonomous(&mut self, val: u32) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn test(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_test(&mut self, val: u32) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn eStop(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_eStop(&mut self, val: u32) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn fmsAttached(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_fmsAttached(&mut self, val: u32) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn dsAttached(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_dsAttached(&mut self, val: u32) {
        self._bitfield_1 &= !(32usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (32usize as u32);
    }
    #[inline]
    pub fn control_reserved(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294967232usize as u32)) >> 6u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_control_reserved(&mut self, val: u32) {
        self._bitfield_1 &= !(4294967232usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 6u32) & (4294967232usize as u32);
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAL_AllianceStationID {
    HAL_AllianceStationID_kRed1 = 0,
    HAL_AllianceStationID_kRed2 = 1,
    HAL_AllianceStationID_kRed3 = 2,
    HAL_AllianceStationID_kBlue1 = 3,
    HAL_AllianceStationID_kBlue2 = 4,
    HAL_AllianceStationID_kBlue3 = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HAL_JoystickAxes {
    pub count: i16,
    pub axes: [f32; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickAxes() {
    assert_eq!(::std::mem::size_of::<HAL_JoystickAxes>() , 52usize);
    assert_eq!(::std::mem::align_of::<HAL_JoystickAxes>() , 4usize);
}
impl Clone for HAL_JoystickAxes {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HAL_JoystickPOVs {
    pub count: i16,
    pub povs: [i16; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickPOVs() {
    assert_eq!(::std::mem::size_of::<HAL_JoystickPOVs>() , 26usize);
    assert_eq!(::std::mem::align_of::<HAL_JoystickPOVs>() , 2usize);
}
impl Clone for HAL_JoystickPOVs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HAL_JoystickButtons {
    pub buttons: u32,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickButtons() {
    assert_eq!(::std::mem::size_of::<HAL_JoystickButtons>() , 8usize);
    assert_eq!(::std::mem::align_of::<HAL_JoystickButtons>() , 4usize);
}
impl Clone for HAL_JoystickButtons {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct HAL_JoystickDescriptor {
    pub isXbox: u8,
    pub type_: u8,
    pub name: [::std::os::raw::c_char; 256usize],
    pub axisCount: u8,
    pub axisTypes: [u8; 12usize],
    pub buttonCount: u8,
    pub povCount: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickDescriptor() {
    assert_eq!(::std::mem::size_of::<HAL_JoystickDescriptor>() , 273usize);
    assert_eq!(::std::mem::align_of::<HAL_JoystickDescriptor>() , 1usize);
}
extern "C" {
    pub fn HAL_SetErrorData(errors: *const ::std::os::raw::c_char,
                            errorsLength: i32, waitMs: i32) -> i32;
}
extern "C" {
    pub fn HAL_SendError(isError: HAL_Bool, errorCode: i32,
                         isLVCode: HAL_Bool,
                         details: *const ::std::os::raw::c_char,
                         location: *const ::std::os::raw::c_char,
                         callStack: *const ::std::os::raw::c_char,
                         printMsg: HAL_Bool) -> i32;
}
extern "C" {
    pub fn HAL_GetControlWord(controlWord: *mut HAL_ControlWord) -> i32;
}
extern "C" {
    pub fn HAL_GetAllianceStation(status: *mut i32) -> HAL_AllianceStationID;
}
extern "C" {
    pub fn HAL_GetJoystickAxes(joystickNum: i32, axes: *mut HAL_JoystickAxes)
     -> i32;
}
extern "C" {
    pub fn HAL_GetJoystickPOVs(joystickNum: i32, povs: *mut HAL_JoystickPOVs)
     -> i32;
}
extern "C" {
    pub fn HAL_GetJoystickButtons(joystickNum: i32,
                                  buttons: *mut HAL_JoystickButtons) -> i32;
}
extern "C" {
    pub fn HAL_GetJoystickDescriptor(joystickNum: i32,
                                     desc: *mut HAL_JoystickDescriptor)
     -> i32;
}
extern "C" {
    pub fn HAL_GetJoystickIsXbox(joystickNum: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetJoystickType(joystickNum: i32) -> i32;
}
extern "C" {
    pub fn HAL_GetJoystickName(joystickNum: i32)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn HAL_GetJoystickAxisType(joystickNum: i32, axis: i32) -> i32;
}
extern "C" {
    pub fn HAL_SetJoystickOutputs(joystickNum: i32, outputs: i64,
                                  leftRumble: i32, rightRumble: i32) -> i32;
}
extern "C" {
    pub fn HAL_GetMatchTime(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_WaitForDSData();
}
extern "C" {
    pub fn HAL_InitializeDriverStation();
}
extern "C" {
    pub fn HAL_ObserveUserProgramStarting();
}
extern "C" {
    pub fn HAL_ObserveUserProgramDisabled();
}
extern "C" {
    pub fn HAL_ObserveUserProgramAutonomous();
}
extern "C" {
    pub fn HAL_ObserveUserProgramTeleop();
}
extern "C" {
    pub fn HAL_ObserveUserProgramTest();
}
extern "C" {
    pub fn HAL_InitializeI2C(port: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_TransactionI2C(port: i32, deviceAddress: i32,
                              dataToSend: *mut u8, sendSize: i32,
                              dataReceived: *mut u8, receiveSize: i32) -> i32;
}
extern "C" {
    pub fn HAL_WriteI2C(port: i32, deviceAddress: i32, dataToSend: *mut u8,
                        sendSize: i32) -> i32;
}
extern "C" {
    pub fn HAL_ReadI2C(port: i32, deviceAddress: i32, buffer: *mut u8,
                       count: i32) -> i32;
}
extern "C" {
    pub fn HAL_CloseI2C(port: i32);
}
pub type HAL_InterruptHandlerFunction =
    ::std::option::Option<unsafe extern "C" fn(interruptAssertedMask: u32,
                                               param:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn HAL_InitializeInterrupts(watcher: HAL_Bool, status: *mut i32)
     -> HAL_InterruptHandle;
}
extern "C" {
    pub fn HAL_CleanInterrupts(interruptHandle: HAL_InterruptHandle,
                               status: *mut i32);
}
extern "C" {
    pub fn HAL_WaitForInterrupt(interruptHandle: HAL_InterruptHandle,
                                timeout: f64, ignorePrevious: HAL_Bool,
                                status: *mut i32) -> i64;
}
extern "C" {
    pub fn HAL_EnableInterrupts(interruptHandle: HAL_InterruptHandle,
                                status: *mut i32);
}
extern "C" {
    pub fn HAL_DisableInterrupts(interruptHandle: HAL_InterruptHandle,
                                 status: *mut i32);
}
extern "C" {
    pub fn HAL_ReadInterruptRisingTimestamp(interruptHandle:
                                                HAL_InterruptHandle,
                                            status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_ReadInterruptFallingTimestamp(interruptHandle:
                                                 HAL_InterruptHandle,
                                             status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_RequestInterrupts(interruptHandle: HAL_InterruptHandle,
                                 digitalSourceHandle: HAL_Handle,
                                 analogTriggerType: HAL_AnalogTriggerType,
                                 status: *mut i32);
}
extern "C" {
    pub fn HAL_AttachInterruptHandler(interruptHandle: HAL_InterruptHandle,
                                      handler: HAL_InterruptHandlerFunction,
                                      param: *mut ::std::os::raw::c_void,
                                      status: *mut i32);
}
extern "C" {
    pub fn HAL_AttachInterruptHandlerThreaded(interruptHandle:
                                                  HAL_InterruptHandle,
                                              handler:
                                                  HAL_InterruptHandlerFunction,
                                              param:
                                                  *mut ::std::os::raw::c_void,
                                              status: *mut i32);
}
extern "C" {
    pub fn HAL_SetInterruptUpSourceEdge(interruptHandle: HAL_InterruptHandle,
                                        risingEdge: HAL_Bool,
                                        fallingEdge: HAL_Bool,
                                        status: *mut i32);
}
pub type HAL_NotifierProcessFunction =
    ::std::option::Option<unsafe extern "C" fn(currentTime: u64,
                                               handle: HAL_NotifierHandle)>;
extern "C" {
    pub fn HAL_InitializeNotifier(process: HAL_NotifierProcessFunction,
                                  param: *mut ::std::os::raw::c_void,
                                  status: *mut i32) -> HAL_NotifierHandle;
}
extern "C" {
    pub fn HAL_InitializeNotifierThreaded(process:
                                              HAL_NotifierProcessFunction,
                                          param: *mut ::std::os::raw::c_void,
                                          status: *mut i32)
     -> HAL_NotifierHandle;
}
extern "C" {
    pub fn HAL_CleanNotifier(notifierHandle: HAL_NotifierHandle,
                             status: *mut i32);
}
extern "C" {
    pub fn HAL_GetNotifierParam(notifierHandle: HAL_NotifierHandle,
                                status: *mut i32)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn HAL_UpdateNotifierAlarm(notifierHandle: HAL_NotifierHandle,
                                   triggerTime: u64, status: *mut i32);
}
extern "C" {
    pub fn HAL_StopNotifierAlarm(notifierHandle: HAL_NotifierHandle,
                                 status: *mut i32);
}
extern "C" {
    pub fn HAL_InitializePDP(module: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_CheckPDPChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_CheckPDPModule(module: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetPDPTemperature(module: i32, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetPDPVoltage(module: i32, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetPDPChannelCurrent(module: i32, channel: i32,
                                    status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetPDPTotalCurrent(module: i32, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetPDPTotalPower(module: i32, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetPDPTotalEnergy(module: i32, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_ResetPDPTotalEnergy(module: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_ClearPDPStickyFaults(module: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_InitializePWMPort(portHandle: HAL_PortHandle, status: *mut i32)
     -> HAL_DigitalHandle;
}
extern "C" {
    pub fn HAL_FreePWMPort(pwmPortHandle: HAL_DigitalHandle,
                           status: *mut i32);
}
extern "C" {
    pub fn HAL_CheckPWMChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetPWMConfig(pwmPortHandle: HAL_DigitalHandle, maxPwm: f64,
                            deadbandMaxPwm: f64, centerPwm: f64,
                            deadbandMinPwm: f64, minPwm: f64,
                            status: *mut i32);
}
extern "C" {
    pub fn HAL_SetPWMConfigRaw(pwmPortHandle: HAL_DigitalHandle, maxPwm: i32,
                               deadbandMaxPwm: i32, centerPwm: i32,
                               deadbandMinPwm: i32, minPwm: i32,
                               status: *mut i32);
}
extern "C" {
    pub fn HAL_GetPWMConfigRaw(pwmPortHandle: HAL_DigitalHandle,
                               maxPwm: *mut i32, deadbandMaxPwm: *mut i32,
                               centerPwm: *mut i32, deadbandMinPwm: *mut i32,
                               minPwm: *mut i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetPWMEliminateDeadband(pwmPortHandle: HAL_DigitalHandle,
                                       eliminateDeadband: HAL_Bool,
                                       status: *mut i32);
}
extern "C" {
    pub fn HAL_GetPWMEliminateDeadband(pwmPortHandle: HAL_DigitalHandle,
                                       status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetPWMRaw(pwmPortHandle: HAL_DigitalHandle, value: i32,
                         status: *mut i32);
}
extern "C" {
    pub fn HAL_SetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, speed: f64,
                           status: *mut i32);
}
extern "C" {
    pub fn HAL_SetPWMPosition(pwmPortHandle: HAL_DigitalHandle, position: f64,
                              status: *mut i32);
}
extern "C" {
    pub fn HAL_SetPWMDisabled(pwmPortHandle: HAL_DigitalHandle,
                              status: *mut i32);
}
extern "C" {
    pub fn HAL_GetPWMRaw(pwmPortHandle: HAL_DigitalHandle, status: *mut i32)
     -> i32;
}
extern "C" {
    pub fn HAL_GetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, status: *mut i32)
     -> f64;
}
extern "C" {
    pub fn HAL_GetPWMPosition(pwmPortHandle: HAL_DigitalHandle,
                              status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_LatchPWMZero(pwmPortHandle: HAL_DigitalHandle,
                            status: *mut i32);
}
extern "C" {
    pub fn HAL_SetPWMPeriodScale(pwmPortHandle: HAL_DigitalHandle,
                                 squelchMask: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetLoopTiming(status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetNumAccumulators() -> i32;
}
extern "C" {
    pub fn HAL_GetNumAnalogTriggers() -> i32;
}
extern "C" {
    pub fn HAL_GetNumAnalogInputs() -> i32;
}
extern "C" {
    pub fn HAL_GetNumAnalogOutputs() -> i32;
}
extern "C" {
    pub fn HAL_GetNumCounters() -> i32;
}
extern "C" {
    pub fn HAL_GetNumDigitalHeaders() -> i32;
}
extern "C" {
    pub fn HAL_GetNumPWMHeaders() -> i32;
}
extern "C" {
    pub fn HAL_GetNumDigitalChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetNumPWMChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetNumDigitalPWMOutputs() -> i32;
}
extern "C" {
    pub fn HAL_GetNumEncoders() -> i32;
}
extern "C" {
    pub fn HAL_GetNumInterrupts() -> i32;
}
extern "C" {
    pub fn HAL_GetNumRelayChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetNumRelayHeaders() -> i32;
}
extern "C" {
    pub fn HAL_GetNumPCMModules() -> i32;
}
extern "C" {
    pub fn HAL_GetNumSolenoidChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetNumPDPModules() -> i32;
}
extern "C" {
    pub fn HAL_GetNumPDPChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetVinVoltage(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetVinCurrent(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserVoltage6V(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserCurrent6V(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserActive6V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetUserCurrentFaults6V(status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetUserVoltage5V(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserCurrent5V(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserActive5V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetUserCurrentFaults5V(status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetUserVoltage3V3(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserCurrent3V3(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserActive3V3(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetUserCurrentFaults3V3(status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_InitializeRelayPort(portHandle: HAL_PortHandle, fwd: HAL_Bool,
                                   status: *mut i32) -> HAL_RelayHandle;
}
extern "C" {
    pub fn HAL_FreeRelayPort(relayPortHandle: HAL_RelayHandle);
}
extern "C" {
    pub fn HAL_CheckRelayChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetRelay(relayPortHandle: HAL_RelayHandle, on: HAL_Bool,
                        status: *mut i32);
}
extern "C" {
    pub fn HAL_GetRelay(relayPortHandle: HAL_RelayHandle, status: *mut i32)
     -> HAL_Bool;
}
extern "C" {
    pub fn HAL_InitializeSPI(port: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_TransactionSPI(port: i32, dataToSend: *mut u8,
                              dataReceived: *mut u8, size: i32) -> i32;
}
extern "C" {
    pub fn HAL_WriteSPI(port: i32, dataToSend: *mut u8, sendSize: i32) -> i32;
}
extern "C" {
    pub fn HAL_ReadSPI(port: i32, buffer: *mut u8, count: i32) -> i32;
}
extern "C" {
    pub fn HAL_CloseSPI(port: i32);
}
extern "C" {
    pub fn HAL_SetSPISpeed(port: i32, speed: i32);
}
extern "C" {
    pub fn HAL_SetSPIOpts(port: i32, msbFirst: HAL_Bool,
                          sampleOnTrailing: HAL_Bool, clkIdleHigh: HAL_Bool);
}
extern "C" {
    pub fn HAL_SetSPIChipSelectActiveHigh(port: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSPIChipSelectActiveLow(port: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetSPIHandle(port: i32) -> i32;
}
extern "C" {
    pub fn HAL_SetSPIHandle(port: i32, handle: i32);
}
extern "C" {
    pub fn HAL_InitSPIAccumulator(port: i32, period: i32, cmd: i32,
                                  xferSize: i32, validMask: i32,
                                  validValue: i32, dataShift: i32,
                                  dataSize: i32, isSigned: HAL_Bool,
                                  bigEndian: HAL_Bool, status: *mut i32);
}
extern "C" {
    pub fn HAL_FreeSPIAccumulator(port: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_ResetSPIAccumulator(port: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSPIAccumulatorCenter(port: i32, center: i32,
                                       status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSPIAccumulatorDeadband(port: i32, deadband: i32,
                                         status: *mut i32);
}
extern "C" {
    pub fn HAL_GetSPIAccumulatorLastValue(port: i32, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetSPIAccumulatorValue(port: i32, status: *mut i32) -> i64;
}
extern "C" {
    pub fn HAL_GetSPIAccumulatorCount(port: i32, status: *mut i32) -> i64;
}
extern "C" {
    pub fn HAL_GetSPIAccumulatorAverage(port: i32, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetSPIAccumulatorOutput(port: i32, value: *mut i64,
                                       count: *mut i64, status: *mut i32);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAL_SerialPort {
    HAL_SerialPort_Onboard = 0,
    HAL_SerialPort_MXP = 1,
    HAL_SerialPort_USB1 = 2,
    HAL_SerialPort_USB2 = 3,
}
extern "C" {
    pub fn HAL_InitializeSerialPort(port: HAL_SerialPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialBaudRate(port: HAL_SerialPort, baud: i32,
                                 status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialDataBits(port: HAL_SerialPort, bits: i32,
                                 status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialParity(port: HAL_SerialPort, parity: i32,
                               status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialStopBits(port: HAL_SerialPort, stopBits: i32,
                                 status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialWriteMode(port: HAL_SerialPort, mode: i32,
                                  status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialFlowControl(port: HAL_SerialPort, flow: i32,
                                    status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialTimeout(port: HAL_SerialPort, timeout: f64,
                                status: *mut i32);
}
extern "C" {
    pub fn HAL_EnableSerialTermination(port: HAL_SerialPort,
                                       terminator: ::std::os::raw::c_char,
                                       status: *mut i32);
}
extern "C" {
    pub fn HAL_DisableSerialTermination(port: HAL_SerialPort,
                                        status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialReadBufferSize(port: HAL_SerialPort, size: i32,
                                       status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialWriteBufferSize(port: HAL_SerialPort, size: i32,
                                        status: *mut i32);
}
extern "C" {
    pub fn HAL_GetSerialBytesReceived(port: HAL_SerialPort, status: *mut i32)
     -> i32;
}
extern "C" {
    pub fn HAL_ReadSerial(port: HAL_SerialPort,
                          buffer: *mut ::std::os::raw::c_char, count: i32,
                          status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_WriteSerial(port: HAL_SerialPort,
                           buffer: *const ::std::os::raw::c_char, count: i32,
                           status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_FlushSerial(port: HAL_SerialPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_ClearSerial(port: HAL_SerialPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_CloseSerial(port: HAL_SerialPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_InitializeSolenoidPort(portHandle: HAL_PortHandle,
                                      status: *mut i32) -> HAL_SolenoidHandle;
}
extern "C" {
    pub fn HAL_FreeSolenoidPort(solenoidPortHandle: HAL_SolenoidHandle);
}
extern "C" {
    pub fn HAL_CheckSolenoidModule(module: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_CheckSolenoidChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetSolenoid(solenoidPortHandle: HAL_SolenoidHandle,
                           status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetAllSolenoids(module: i32, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_SetSolenoid(solenoidPortHandle: HAL_SolenoidHandle,
                           value: HAL_Bool, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAllSolenoids(module: i32, state: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetPCMSolenoidBlackList(module: i32, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetPCMSolenoidVoltageStickyFault(module: i32, status: *mut i32)
     -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetPCMSolenoidVoltageFault(module: i32, status: *mut i32)
     -> HAL_Bool;
}
extern "C" {
    pub fn HAL_ClearAllPCMStickyFaults(module: i32, status: *mut i32);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAL_RuntimeType { HAL_Athena = 0, HAL_Mock = 1, }
extern "C" {
    pub fn HAL_GetErrorMessage(code: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn HAL_GetFPGAVersion(status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetFPGARevision(status: *mut i32) -> i64;
}
extern "C" {
    pub fn HAL_GetRuntimeType() -> HAL_RuntimeType;
}
extern "C" {
    pub fn HAL_GetFPGAButton(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetSystemActive(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetBrownedOut(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_BaseInitialize(status: *mut i32);
}
extern "C" {
    pub fn HAL_GetPort(channel: i32) -> HAL_PortHandle;
}
extern "C" {
    pub fn HAL_GetPortWithModule(module: i32, channel: i32) -> HAL_PortHandle;
}
extern "C" {
    pub fn HAL_GetFPGATime(status: *mut i32) -> u64;
}
extern "C" {
    pub fn HAL_Initialize(mode: i32) -> i32;
}
extern "C" {
    pub fn HAL_Report(resource: i32, instanceNumber: i32, context: i32,
                      feature: *const ::std::os::raw::c_char) -> i64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tCANStreamMessage {
    pub messageID: u32,
    pub timeStamp: u32,
    pub data: [u8; 8usize],
    pub dataSize: u8,
}
#[test]
fn bindgen_test_layout_tCANStreamMessage() {
    assert_eq!(::std::mem::size_of::<tCANStreamMessage>() , 20usize);
    assert_eq!(::std::mem::align_of::<tCANStreamMessage>() , 4usize);
}
impl Clone for tCANStreamMessage {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_sendMessage(messageID: u32,
                                                              data: *const u8,
                                                              dataSize: u8,
                                                              periodMs: i32,
                                                              status:
                                                                  *mut i32);
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_receiveMessage(messageID:
                                                                     *mut u32,
                                                                 messageIDMask:
                                                                     u32,
                                                                 data:
                                                                     *mut u8,
                                                                 dataSize:
                                                                     *mut u8,
                                                                 timeStamp:
                                                                     *mut u32,
                                                                 status:
                                                                     *mut i32);
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_openStreamSession(sessionHandle:
                                                                        *mut u32,
                                                                    messageID:
                                                                        u32,
                                                                    messageIDMask:
                                                                        u32,
                                                                    maxMessages:
                                                                        u32,
                                                                    status:
                                                                        *mut i32);
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_closeStreamSession(sessionHandle:
                                                                         u32);
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_readStreamSession(sessionHandle:
                                                                        u32,
                                                                    messages:
                                                                        *mut tCANStreamMessage,
                                                                    messagesToRead:
                                                                        u32,
                                                                    messagesRead:
                                                                        *mut u32,
                                                                    status:
                                                                        *mut i32);
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_getCANStatus(percentBusUtilization:
                                                                   *mut f32,
                                                               busOffCount:
                                                                   *mut u32,
                                                               txFullCount:
                                                                   *mut u32,
                                                               receiveErrorCount:
                                                                   *mut u32,
                                                               transmitErrorCount:
                                                                   *mut u32,
                                                               status:
                                                                   *mut i32);
}
extern "C" {
    pub fn canTxSend(arbID: u32, length: u8, period: i32);
}
extern "C" {
    pub fn canTxPackInt8(arbID: u32, offset: u8, value: u8);
}
extern "C" {
    pub fn canTxPackInt16(arbID: u32, offset: u8, value: u16);
}
extern "C" {
    pub fn canTxPackInt32(arbID: u32, offset: u8, value: u32);
}
extern "C" {
    pub fn canTxPackFXP16(arbID: u32, offset: u8, value: f64);
}
extern "C" {
    pub fn canTxPackFXP32(arbID: u32, offset: u8, value: f64);
}
extern "C" {
    pub fn canTxUnpackInt8(arbID: u32, offset: u8) -> u8;
}
extern "C" {
    pub fn canTxUnpackInt32(arbID: u32, offset: u8) -> u32;
}
extern "C" {
    pub fn canTxUnpackInt16(arbID: u32, offset: u8) -> u16;
}
extern "C" {
    pub fn canTxUnpackFXP16(arbID: u32, offset: u8) -> f64;
}
extern "C" {
    pub fn canTxUnpackFXP32(arbID: u32, offset: u8) -> f64;
}
extern "C" {
    pub fn canRxReceive(arbID: u32) -> bool;
}
extern "C" {
    pub fn canRxUnpackInt8(arbID: u32, offset: u8) -> u8;
}
extern "C" {
    pub fn canRxUnpackInt16(arbID: u32, offset: u8) -> u16;
}
extern "C" {
    pub fn canRxUnpackInt32(arbID: u32, offset: u8) -> u32;
}
extern "C" {
    pub fn canRxUnpackFXP16(arbID: u32, offset: u8) -> f64;
}
extern "C" {
    pub fn canRxUnpackFXP32(arbID: u32, offset: u8) -> f64;
}
extern "C" {
    pub fn HAL_InitializeOSSerialPort(port: HAL_SerialPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetOSSerialBaudRate(port: HAL_SerialPort, baud: i32,
                                   status: *mut i32);
}
extern "C" {
    pub fn HAL_SetOSSerialDataBits(port: HAL_SerialPort, bits: i32,
                                   status: *mut i32);
}
extern "C" {
    pub fn HAL_SetOSSerialParity(port: HAL_SerialPort, parity: i32,
                                 status: *mut i32);
}
extern "C" {
    pub fn HAL_SetOSSerialStopBits(port: HAL_SerialPort, stopBits: i32,
                                   status: *mut i32);
}
extern "C" {
    pub fn HAL_SetOSSerialWriteMode(port: HAL_SerialPort, mode: i32,
                                    status: *mut i32);
}
extern "C" {
    pub fn HAL_SetOSSerialFlowControl(port: HAL_SerialPort, flow: i32,
                                      status: *mut i32);
}
extern "C" {
    pub fn HAL_SetOSSerialTimeout(port: HAL_SerialPort, timeout: f64,
                                  status: *mut i32);
}
extern "C" {
    pub fn HAL_EnableOSSerialTermination(port: HAL_SerialPort,
                                         terminator: ::std::os::raw::c_char,
                                         status: *mut i32);
}
extern "C" {
    pub fn HAL_DisableOSSerialTermination(port: HAL_SerialPort,
                                          status: *mut i32);
}
extern "C" {
    pub fn HAL_SetOSSerialReadBufferSize(port: HAL_SerialPort, size: i32,
                                         status: *mut i32);
}
extern "C" {
    pub fn HAL_SetOSSerialWriteBufferSize(port: HAL_SerialPort, size: i32,
                                          status: *mut i32);
}
extern "C" {
    pub fn HAL_GetOSSerialBytesReceived(port: HAL_SerialPort,
                                        status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_ReadOSSerial(port: HAL_SerialPort,
                            buffer: *mut ::std::os::raw::c_char, count: i32,
                            status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_WriteOSSerial(port: HAL_SerialPort,
                             buffer: *const ::std::os::raw::c_char,
                             count: i32, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_FlushOSSerial(port: HAL_SerialPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_ClearOSSerial(port: HAL_SerialPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_CloseOSSerial(port: HAL_SerialPort, status: *mut i32);
}
